---
title: "MissingData"
author: "William Nguyen"
date: "10/4/2020"
output: 
  html_document:
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Imputing missing water quality data in the Howler Monkey Watershed

There's a couple ad-hoc ways of dealing with miss data, such as listwise deletion and mean imputation. Listwise deletion only really works when you have a few missing values and mean imputation brings too much bias to variances and covariances. In this example, I'll be using Amelia to perform multiple imputation, which should give me some probable predictions for my missing values.

In the future, I may want to implement some more robust means of imputation, such as CART, random forest, and artificial neural networks, but I'll save that for the manuscript. 

```{r Installing libraries, include = FALSE, warning=FALSE}
library(Amelia)
library(tidyverse)
library(dplyr)
library(ggthemes)
library(naniar) # for replace functions
library(VIM)
library(FactoMineR)
library(missMDA)
```

OK first, I'm going to take a stab as missMDA in R.
```{r}
#library(missMDA)
data("orange")
nb <- estim_ncpPCA(orange, scale=TRUE) ## Estimate no. of dimensions
comp <- imputePCA(orange, ncp=2, scale=TRUE) ## Impute the table
res.pca <- PCA(comp$completeObs) ## Do the PCA
```

Visualizing uncertainty due to missing data with missMDA:
```{r}
mi <- MIPCA(orange, scale = TRUE, ncp = 2)
plot(mi)
```

Another demo using genotype-environment data set (from vignette)

```{r missMDA on geno data}
set.seed(1234)
# library(missMDA)
data("geno", package = "missMDA")
summary(geno)
head(round(geno,2))
```
```{r missMDA on geno data pt 2}
ncomp <- estim_ncpPCA(geno, ncp.min=0, ncp.max=6) # by default, estim_ncpPCA using GCV method, could using Kfold by specifying method.cv="Kfold" (would be good to add two individual argumnts, pNA = 0.05, nbsim=100)
ncomp$ncp # returns NSEP for no. of dimensions minimizing the MSEP in object ncp (should be 2-D)
res.imp <- imputePCA(geno, ncp = 2, scale = TRUE, method = "Regularized", row.w = NULL, coeff.ridge = 1, threshold = 1e-06, seed = NULL, nb.init = 1, maxiter = 1000)
head(round(res.imp$completeObs, 2))
res.pca <- PCA(res.imp$completeObs)
```

To perform multiple imputation, we use the MIPCA function, which generates multiple imputed data sets. Then, the plot method for 'MIPCA' objects is applied to visualize the impact of the different imputed values on the PCA results.

```{r Multiple imputation for missMDA}
resMIPCA <- MIPCA(geno, ncp = 2, nboot = 200)
plot(resMIPCA)
```

```{r MIPCA but with the arguments}
plot(resMIPCA, choice = "all", axes = c(1,2), new.plot = TRUE, main = NULL, level.conf = 0.95)
```


```{r Reading in data}
df <- read.csv("https://raw.githubusercontent.com/wdnguyen/CR/master/CostaRica_Chemistry_Q_20201002.csv", stringsAsFactors = FALSE)
df$SamplingDate <- as.POSIXct(df$SamplingDate, format ="%m/%d/%y %H:%M")

### For now, let's set BDL as 0.1, globally (across all data)
df <- dplyr::mutate_if(tibble::as_tibble(df), # changed as.tibble to as_tibble
                       is.character,
                       stringr::str_replace_all, pattern = "BDL", replacement = "0.1")

### Convert character vectors into numeric (hopefully blanks become NA)
df[,c(12,13,15,17,19,24,28)] <- sapply(df[,c(12,13,15,17,19,24,28)], as.numeric) # NH3_f, H2S_f, Fetot, Mn_f, As_f, F, Li

### And for good measure, I will replace all negative concentrations with NA. https://cran.r-project.org/web/packages/naniar/vignettes/replace-with-na.html
df <- df %>%
  replace_with_na_at(.vars = c("Mo","U","Al","Si","Ca","Cr","Fe","Ti","B","Ba","As"),
                     condition = ~.x < 0) # I could have just used replace_with_na_all, but O18 and D have natural negative values

# For some reason, df ID is coming out all weird
names(df)[1] <- "ID"

# Let's also just drop some columns that are REALLY lacking data: AlkalinityS, Mn_f, SO4_f, As_f
df <- subset(df, select = -c(AlkalinityS, O2, SO4_f, As_f, B, Ba, Fetot, Mn_f, TotalNField, Sr2, U, Mo, Cd, Sb, Pb))

# Remove DS9Bot, Howler Weir
df <- df[-c(21, 31),] 

### 2018 df
df2018 <- df[format(df$SamplingDate, '%Y') != "2019", ]

### Subsetting data by site / end-member
DS <- subset(df, Site == "Downstream")
US <- subset(df, Site == "Upstream")
SOIL <- subset(df, Site == "Soil")
RAIN <- subset(df, Site == "Rain")
SPRING <- subset(df, Site == "Spring")

### Just 2018 Data
DS2018 <- DS[format(DS$SamplingDate, '%Y') != "2019", ]
US2018 <- US[format(US$SamplingDate, '%Y') != "2019", ]
SOIL2018 <- SOIL[format(SOIL$SamplingDate, '%Y') != "2019", ]
RAIN2018 <- RAIN[format(RAIN$SamplingDate, '%Y') != "2019", ]
SPRING2018 <- SPRING[format(SPRING$SamplingDate, '%Y') != "2019", ]
```

OK cool, let's do a summary of df:

```{r summary}
summary(df)
```

So, for my imputations, it probably makes sense to do them by end member/group.

First, I'll do a rough PCA with not-so-great imputation. The incomplete data set can be imputed using the function imputePCA performing the iterative PCA algorithm, specifying the number of dimensions through the argument ncp=2. At convergence the algorithm provides both an estimation of the scores and loadings as well as a completed data set. The imputePCA function outputs the imputed data set. The completed data set is in the object completeObs. The imputePCA function also outputs the fitted matrix X^ in the object fitted. http://juliejosse.com/wp-content/uploads/2018/05/DataAnalysisMissingR.html

```{r PCA with missing values using imputePCA}
### must have missMDA
# df1 <- df[,c(6:9,11:14,20:60)]
# np <- estim_ncpPCA(df1, method.cv = "Kfold", verbose = FALSE)
# plot(0:5, np$criterion, xlab = "np dim", ylab = "MSEP")
# res.comp <- imputePCA(df1, ncp = np$ncp) # iterativePCA algorithm
# res.comp$completeObs[1:3,]
# imp <- cbind.data.frame(res.comp$completeObs,df$Site)
# res.pca <- PCA(imp, quanti.sup = 12, quali.sup = 50, ncp = np$ncp, graph=FALSE) ### Cl (12) as quan, Site (50) as qual
# plot(res.pca, hab=50, lab="quali");
# plot(res.pca, choix="var")
```

OK, now for the real deal with Amelia and multiple imputation, which assumes Joint Modeling (one joint probabilistic model for the variables all together)

```{r Amelia}
# ignore_vars <- c("ID", "Chemetrics_Acidified_Date", "Source", "Q", "Seconds")
# a.out <- amelia(df,                   # data set
#                m = 5,                # number of imputations, usually 5
#                ts = "SamplingDate",  # time series
#                cs = "Site",          # cross section
#                idvars = ignore_vars) # vars to leave out of imputation
```

```{r}
#ignore_vars <- c("ID", "Site", "Chemetrics_Acidified_Date", "Source", "Q", "Seconds", "Temp", "pH", "ORP")
#a.out <- amelia(DS2019,                   # data set
#                m = 5,                # number of imputations, usually 5
#                ts = "SamplingDate",  # time series
#                idvars = ignore_vars, # vars to leave out of imputation
#                empri = 20)
```

OK, so Amelia flopped hard. I have too many missing values to imputate. So let's try a different approach. 

```{r Let's impute by end member group / mixing sample}
nb 
nb <- estim_ncpPCA(df, method.cv = "Kfold")
ggplot(data = NULL, aes(x = 0:5, y = nb$criterion)) + 
    geom_point() + 
    geom_line() + 
    xlab("nb dim") + 
    ylab("MSEP")
```

